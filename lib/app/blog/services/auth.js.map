{"version":3,"sources":["/var/snap-ci/repo/src/app/blog/services/auth.js"],"names":[],"mappings":"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","file":"/var/snap-ci/repo/src/app/blog/services/auth.js","sourcesContent":["import {Redirect} from 'aurelia-router';\n\nconst SIMULATE_LATENCY = true;\n\nfunction returnData(fn) {\n  if (SIMULATE_LATENCY) {\n    return new Promise(resolve => setTimeout(() => resolve(), 500))\n      .then(() => new Promise(fn));\n  } else {\n    return new Promise(fn);\n  }\n}\n\nlet user = null;\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport class AuthenticationService {\n  get user() {\n    return user;\n  }\n\n  checkLogin() {\n    // If ther is no local user, then there is no point in running\n    // a request to the server.\n    if (user === null)\n      return Promise.resolve(null);\n\n    // In a real world environment, where a user is signed in to a\n    // server, using cookies or something similar, that login might\n    // expire, without the client beeing notified.\n    // This here is to simulate a request to the server,\n    // to ensure we're still logged in.\n    return returnData(resolve => resolve(true))\n      .then(status => {\n        // true here could indicate we're still logged in,\n        // whereas false would be not logged in.\n        if (status === false) {\n          // if the login has expired on the server, delete the\n          // one on the client as well.\n          user = null;\n        }\n\n        // Return the user as a convenience, so we can just\n        // use the value without having to reacquire it from\n        // the service.\n        return user;\n      });\n  }\n\n  hasGroups(username, groups) {\n    // Check if user has admin rights.\n    return returnData(resolve => resolve(true));\n  }\n\n  login(username, password) {\n    // this is a demo, accept anyone with a password of \"test\"\n    // in reality, there would also be more checks to prevent\n    // sending off multiple login requests at once\n    if (password === 'test') {\n      return returnData(resolve => {\n        user = new User(username);\n        resolve(true);\n      });\n    } else {\n      return returnData(resolve => resolve(false));\n    }\n  }\n\n  logout() {\n    if (user === null) {\n      // If there is no user, return success.\n      return Promise.resolve(true);\n    }\n\n    return returnData(resolve => {\n      user = null;\n      resolve(true);\n    });\n  }\n}\n\nexport class AuthorizeStep {\n  static inject() { return [AuthenticationService]; }\n  constructor(authenticationService) {\n    this.auth = authenticationService;\n  }\n\n  run(routingContext, next) {\n    // Check for the routes \"auth\" key.\n    const authRoutes = routingContext.nextInstructions.filter(i => i.config.auth);\n    if (authRoutes.length === 0)\n      return next();\n\n    // If any of the auth-keys are a string,\n    // treat this as a group name.\n    const groups = authRoutes.map(r => r.config.auth).filter(a => typeof a === 'string');\n\n    // Check that the user is logged in.\n    return this.auth.checkLogin().then(user => {\n      if (user === null)\n        return false;\n\n      if (groups.length === 0)\n        return true;\n\n      return this.auth.hasGroups(user.name, groups);\n    }).then(authorized => {\n      if (authorized)\n        return next();\n\n      return next.cancel(new Redirect('/blog/login'));\n    });\n  }\n}"]}